using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using SPN;

namespace SePtoN_Exploit
{
	class Program
	{
		private static byte[] ExpectedKey;

		static void Main(string[] args)
		{
			var testMode = false;

			if(testMode)
			{
				TestSploit(args);
				return;
			}

			if(args.Length < 1)
			{
				Console.WriteLine("Usage: sploit.exe <fileToDecrypt> [expectedKey]");
				Environment.Exit(1);
			}

			ExpectedKey = args.Length >= 2 ? File.ReadAllBytes(args[1]) : new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

			byte[] imageBytes;
			try
			{
				imageBytes = File.ReadAllBytes(args[0]);
			}
			catch(Exception e)
			{
				Console.WriteLine($"Can't read data from file {args[0]}", e);
				Environment.Exit(1);
				return;
			}

			var spn = new SubstitutionPermutationNetwork(SubstitutionPermutationNetwork.GenerateRandomKey());

			var pairs = GeneratePlainEncryptedPairs(imageBytes);
			var plains = pairs.Select(tuple => tuple.Item1).ToArray();
			var encs = pairs.Select(tuple => tuple.Item2).ToArray();

			iterationsCount = pairs.Count;


			var linearCryptoanalysis = new LinearCryptoanalysis(spn);
			var bestLayerApproximations = linearCryptoanalysis.ChooseBestPathsStartingFromSingleSBoxInRound0(maxSBoxesInLastRound, maxSBoxesInRound, thresholdBias).ToList();
			Console.WriteLine($"Total approximations: {bestLayerApproximations.Count}");

			var solutions = new List<Solution>();
			foreach(var approximationsGroup in bestLayerApproximations
				.Where(layer => layer.round0sboxNum % 8 == 3 || (layer.round0sboxNum % 8 == 4 && ((layer.round0x & 0x01) == 0)))
				.GroupBy(layer => layer.ActivatedSboxesNums.Aggregate("", (s, num) => s + num))
				.OrderBy(group => group.Key))
			{
				foreach(var approximation in approximationsGroup.Distinct().OrderByDescending(layer => layer.inputProbability.Bias()).Take(6))
					solutions.AddRange(HackApproximation(plains, encs, approximation));
			}

			var solutionsDict = OrderSolutions(solutions);

			var imageLength = imageBytes.Length - SubstitutionPermutationNetwork.GenerateRandomIV().Length;
			if(imageLength >= 65536)
				throw new Exception("Unexpected image ciphertext length");

			var plaintextPrefixFrom4 = new byte[] { 0, 0, 0, 0, 0, 0, 0x36, 0, 0, 0 };
			var hackedKey = GetFinalSolution(solutionsDict, imageBytes.Take(24).ToArray(), plaintextPrefixFrom4);
			if(hackedKey != null)
				Console.WriteLine($"\nHACKED KEY: {hackedKey.ToHexUpperCase()}");
			else
				Console.WriteLine("BAD LUCK. Key not hacked");
		}

		private static byte[] GetFinalSolution(Dictionary<int, List<byte>> solutionsDict, byte[] ciphertextBlocks, byte[] expectedPlaintextPrefixFrom4)
		{
			var key = new byte[SubstitutionPermutationNetwork.KeySizeBytes];

			byte b = 0;
			var keyLengthInHex = SubstitutionPermutationNetwork.KeySizeBytes * 8 / SBox.BitSize;
			for(int hexNumPos = 0; hexNumPos < keyLengthInHex; hexNumPos++)
			{
				byte hexNum = 0;
				if(solutionsDict.ContainsKey(hexNumPos))
					hexNum = solutionsDict[hexNumPos].First(); //TODO this position definitely needs to be bruted

				b |= (byte)(hexNum << (hexNumPos % 2 == 0 ? 4 : 0));

				if(hexNumPos % 2 == 1)
				{
					key[hexNumPos / 2] = b;
					b = 0;
				}
			}
			var spn = new SubstitutionPermutationNetwork(key);

			for(int d1pos = 0; d1pos < keyLengthInHex; d1pos++)
			{
				for(int d2pos = 0; d2pos < keyLengthInHex; d2pos++)
				{
					if(d2pos == d1pos)
						continue;
					for(int d3pos = 0; d3pos < keyLengthInHex; d3pos++)
					{
						if(d3pos == d1pos || d3pos == d2pos)
							continue;

						var d1prev = GetHex(key, d1pos);
						//TODO itarate solutionsDict, not full brute!

						for(byte d1v = 0; d1v < 16; d1v++)
						{
							SetHex(key, d1pos, d1v);

							var d2prev = GetHex(key, d2pos);
							for(byte d2v = 0; d2v < 16; d2v++)
							{
								SetHex(key, d2pos, d2v);

								byte d3prev = GetHex(key, d3pos);
								for(byte d3v = 0; d3v < 16; d3v++)
								{
									spn.MasterKey = key;
									var plaintextBlocks = spn.DecryptCBC(ciphertextBlocks);
									if(StartsWith(plaintextBlocks, 4, expectedPlaintextPrefixFrom4))
										return key;
								}
								SetHex(key, d3pos, d3prev);
							}
							SetHex(key, d2pos, d2prev);
						}
						SetHex(key, d1pos, d1prev);
					}
				}
			}
			return null;
		}

		private static byte GetHex(byte[] arr, int hexPos)
		{
			byte prev;
			if(hexPos % 2 == 0)
				prev = (byte)((arr[hexPos / 2] & 0xF0) >> 4);
			else
				prev = (byte)(arr[hexPos / 2] & 0x0F);
			return prev;
		}

		private static void SetHex(byte[] arr, int hexPos, byte value)
		{
			if(hexPos % 2 == 0)
			{
				arr[hexPos / 2] &= 0x0F;
				arr[hexPos / 2] |= (byte)(value << 4);
			}
			else
			{
				arr[hexPos / 2] &= 0xF0;
				arr[hexPos / 2] |= value;
			}
		}

		private static bool StartsWith(byte[] data, int dataOffset, byte[] prefix)
		{
			for(int i = 0; i < prefix.Length; i++)
			{
				if(data[dataOffset + i] != prefix[i])
					return false;
			}
			return true;
		}

		private static List<(byte[], byte[])> GeneratePlainEncryptedPairs(byte[] imageBytes)
		{
			var result = new List<(byte[], byte[])>();
			var prefixWithEncryptedPixels = imageBytes.Skip(SubstitutionPermutationNetwork.GenerateRandomIV().Length + 0x38 - SubstitutionPermutationNetwork.BlockSizeBytes).ToList();
			for(int i = SubstitutionPermutationNetwork.BlockSizeBytes; i < prefixWithEncryptedPixels.Count - SubstitutionPermutationNetwork.BlockSizeBytes; i += SubstitutionPermutationNetwork.BlockSizeBytes)
			{
				var prevC = prefixWithEncryptedPixels.Skip(i - SubstitutionPermutationNetwork.BlockSizeBytes).Take(SubstitutionPermutationNetwork.BlockSizeBytes).ToArray();
				var c = prefixWithEncryptedPixels.Skip(i).Take(SubstitutionPermutationNetwork.BlockSizeBytes).ToArray();

				var expectedP = new byte[] { 0, 0xFF, 0, 0, 0, 0xFF, 0, 0};

				var input = SubstitutionPermutationNetwork.XorBlock(prevC, expectedP);
				result.Add((input, c));
			}
			return result;
		}

		static void TestSploit(string[] args)
		{
			Console.WriteLine($"SPN: rounds {SubstitutionPermutationNetwork.RoundsCount}, blocksize {SubstitutionPermutationNetwork.BlockSizeBytes * 8 } bits");

			ExpectedKey = SubstitutionPermutationNetwork.GenerateRandomKey();
			Console.WriteLine($"key: {ExpectedKey.ToHexUpperCase()}");

			var spn = new SubstitutionPermutationNetwork(ExpectedKey);

			var plainTextString = new string('X', SubstitutionPermutationNetwork.BlockSizeBytes);
			var plainText = Encoding.ASCII.GetBytes(plainTextString);
			var encryptedBytes = spn.EncryptBlock(plainText);
			var decryptedBytes = spn.DecryptBlock(encryptedBytes);
			var decryptedString = Encoding.ASCII.GetString(decryptedBytes);
			Console.WriteLine($"{plainTextString} -> {encryptedBytes.ToHexUpperCase()} -> {decryptedString}");

			iterationsCount = 6000;
			Test_HackCipher(spn);
		}

		const double thresholdBias = 0.008;
		const int maxSBoxesInLastRound = 2;
		const int maxSBoxesInRound = 2 * maxSBoxesInLastRound;

		static int iterationsCount;


		private static void Test_HackCipher(SubstitutionPermutationNetwork spn)
		{
			var linearCryptoanalysis = new LinearCryptoanalysis(spn);

			var bestLayerApproximations = linearCryptoanalysis.ChooseBestPathsStartingFromSingleSBoxInRound0(maxSBoxesInLastRound, maxSBoxesInRound, thresholdBias).ToList();
			Console.WriteLine($"Total approximations: {bestLayerApproximations.Count}");

			var plains = Enumerable.Range(0, iterationsCount).Select(i => Test_GenerateRandomPlainText()).ToArray();
			var encs = plains.Select(plain => spn.EncryptBlock(plain)).ToArray();

			var solutions = new List<Solution>();
			foreach(var approximationsGroup in bestLayerApproximations
															.Where(layer => layer.round0sboxNum % 8 == 6 || (layer.round0sboxNum % 8 == 7 && ((layer.round0x & 0x01) == 0)))
															.GroupBy(layer => layer.ActivatedSboxesNums.Aggregate("", (s, num) => s + num))
															.OrderBy(group => group.Key))

			//													.Where(layer => layer.round0sboxNum % 2 == 0 && layer.round0x == 0x8)
			//													.GroupBy(layer => layer.ActivatedSboxesNums.Aggregate("", (s, num) => s + num))
			//													.OrderBy(group => group.Key))
			{
				foreach(var approximation in approximationsGroup.Distinct().OrderByDescending(layer => layer.inputProbability.Bias()).Take(3))
					solutions.AddRange(HackApproximation(plains, encs, approximation));
			}

			OrderSolutions(solutions);
		}

		private static Dictionary<int, List<byte>> OrderSolutions(List<Solution> solutions)
		{
			var result = new Dictionary<int, List<byte>>();

			var keyCandidate = new string(' ', 2 * ExpectedKey.Length).ToCharArray();
			var lines = new List<char[]>();

			foreach(var sboxNumGroup in solutions.GroupBy(solution => solution.SBoxNum).OrderBy(grouping => grouping.Key))
			{
				var hexNum = sboxNumGroup.Key;

				var candidates = sboxNumGroup
					.GroupBy(solution => solution.HalfByte)
					.Select(g =>
					{
						var sumScores = g.Aggregate(0.0, (s, solution) => s + solution.score);
						return (g, sumScores);
					})
					.OrderByDescending(tuple => tuple.sumScores)
					.ToList();


				for(int i = 0; i < candidates.Count; i++)
				{
					var group = candidates[i];
					if(lines.Count == i)
						lines.Add(keyCandidate.ToArray());

					lines[i][hexNum] = group.g.Key.ToHex4B();

//					Console.WriteLine($"{sboxNumGroup.Key}: {group.g.Key.ToHex4B()} = {group.sumScores}");
				}

				result[hexNum] = candidates.Select(tuple => tuple.g.Key).ToList();
			}

			Console.WriteLine();
			foreach(var line in lines)
				Console.WriteLine(new string(line));

			return result;
		}


		private static List<Solution> HackApproximation(byte[][] plains, byte[][] encs, Layer bestLayerApproximation)
		{
			Console.WriteLine($"\nBEST OPTION: round0sboxNum {bestLayerApproximation.round0sboxNum}\tround0x {bestLayerApproximation.round0x}\tround0y {bestLayerApproximation.round0y}\tbias {bestLayerApproximation.inputProbability.Bias()}\toutSBoxes {string.Join(",", bestLayerApproximation.ActivatedSboxesNums)}\tLastRoundInputBits {SubstitutionPermutationNetwork.GetBitString(bestLayerApproximation.inputBits)}");

			var targetPartialSubkeys = GenerateTargetPartialSubkeys(bestLayerApproximation.ActivatedSboxesNums)
				.Select(targetPartialSubkey => (targetPartialSubkey, SubstitutionPermutationNetwork.GetBytesBigEndian(targetPartialSubkey)))
				.ToList();

			var keyProbabilities = targetPartialSubkeys
				.ToDictionary(u => u.Item1, u => 0);
			var hackingSubstitutionPermutationNetwork = new SubstitutionPermutationNetwork(SubstitutionPermutationNetwork.GenerateRandomKey());

			for(int i = 0; i < plains.Length; i++)
			{
				if(i > 0 && i % (plains.Length / 4) == 0)
				{
					Console.WriteLine($" done {i} iterations of {iterationsCount}");
				}

				var plain = plains[i];
				var enc = encs[i];

				HackIteration(plain, enc, bestLayerApproximation.round0sboxNum, bestLayerApproximation.round0x, bestLayerApproximation.inputBits, targetPartialSubkeys, hackingSubstitutionPermutationNetwork, keyProbabilities);
			}

			return GetSolutions(bestLayerApproximation, keyProbabilities);
		}

		private static void HackIteration(byte[] plain, byte[] enc, int round0sboxNum, ulong round0x, ulong lastRoundInputBits, List<(ulong, byte[])> targetPartialSubkeys, SubstitutionPermutationNetwork hackingSubstitutionPermutationNetwork, Dictionary<ulong, int> keyProbabilities)
		{
			var p_setBitsCount = SubstitutionPermutationNetwork.CountBits(SubstitutionPermutationNetwork.GetUlongBigEndian(plain) & (round0x << ((SubstitutionPermutationNetwork.RoundSBoxesCount - round0sboxNum - 1) * SBox.BitSize)));

			var encUnkeyed = new byte[enc.Length];
			foreach(var (targetPartialSubkey, subkeyBytes) in targetPartialSubkeys)
			{
				for(int i = 0; i < subkeyBytes.Length; i++)
					encUnkeyed[i] = (byte)(enc[i] ^ subkeyBytes[i]);

				hackingSubstitutionPermutationNetwork.DecryptRound(encUnkeyed, null, hackingSubstitutionPermutationNetwork.sboxes[SubstitutionPermutationNetwork.RoundsCount - 1], true, true);

				var u_setBitsCount = SubstitutionPermutationNetwork.CountBits(lastRoundInputBits & SubstitutionPermutationNetwork.GetUlongBigEndian(encUnkeyed));

				if((p_setBitsCount + u_setBitsCount) % 2 == 0)
					keyProbabilities[targetPartialSubkey]++;
			}
		}

		private static List<Solution> GetSolutions(Layer bestLayerApproximation, Dictionary<ulong, int> keyProbabilities)
		{
			Console.WriteLine($"ITERATIONS DONE: {iterationsCount}");
			Console.ForegroundColor = ConsoleColor.Blue;
			Console.WriteLine($" {ExpectedKey.ToHexUpperCase()} : REAL KEY");
			Console.ResetColor();

			var expectedCountBias = Math.Abs(0.5 - bestLayerApproximation.inputProbability) * iterationsCount;

			var keyValuePairs = keyProbabilities.OrderByDescending(kvp => Math.Abs(iterationsCount / 2 - kvp.Value)).ToList();
			var gotCountBias = Math.Abs(iterationsCount / 2 - keyValuePairs[0].Value);

			var solutions = new List<Solution>();

			if(Math.Abs(expectedCountBias - gotCountBias) > expectedCountBias / 2)
			{
				Console.ForegroundColor = ConsoleColor.Red;
				Console.WriteLine($" best {gotCountBias} expected {expectedCountBias}");
				Console.ResetColor();
				return solutions;
			}

			int groupNum = 0;
			int prevBias = -1;
			var prefix = "";
			foreach(var kvp in keyValuePairs.Take(16))
			{
				var keyBytes = SubstitutionPermutationNetwork.GetBytesBigEndian(kvp.Key);
				var isValidKey = IsValidKey(ExpectedKey, keyBytes, bestLayerApproximation.ActivatedSboxesNums);

				var bias = Math.Abs(iterationsCount / 2 - kvp.Value);

				if(bias != prevBias && prevBias != -1)
				{
					prefix = prefix == " " ? "" : " ";
					groupNum++;
				}

				if(isValidKey)
					Console.ForegroundColor = ConsoleColor.Green;
				Console.WriteLine($"{prefix}{keyBytes.ToHexUpperCase()} : {bias}");
				Console.ResetColor();
				prevBias = bias;

				if(groupNum < 3)
				{
					solutions.AddRange(GetSolutions(keyBytes, bestLayerApproximation.ActivatedSboxesNums, groupNum));
				}
			}

			return solutions;
		}

		private static List<ulong> GenerateTargetPartialSubkeys(List<int> vulnerableLastRoundSBoxesNums)
		{
			var targetPartialSubkeys = new List<ulong> { 0u };

			while(vulnerableLastRoundSBoxesNums.Count > 0)
			{
				var sBoxNum = vulnerableLastRoundSBoxesNums.Last();

				var newTargetPartialSubkeys = new List<ulong>();
				foreach(var targetPartialSubkey in targetPartialSubkeys)
					for(ulong v = 0; v < 1u << SBox.BitSize; v++)
						newTargetPartialSubkeys.Add(targetPartialSubkey | SubstitutionPermutationNetwork.GetBitMask(sBoxNum, v));
				targetPartialSubkeys = newTargetPartialSubkeys;

				vulnerableLastRoundSBoxesNums.RemoveAt(vulnerableLastRoundSBoxesNums.Count - 1);
			}

			return targetPartialSubkeys;
		}

		private static byte[] Test_GenerateRandomPlainText()
		{
			var block = new byte[SubstitutionPermutationNetwork.KeySizeBytes];
			new RNGCryptoServiceProvider().GetBytes(block);
			return block;
		}

		private static IEnumerable<Solution> GetSolutions(byte[] got, List<int> activatedSboxesNums, int groupNum)
		{
			foreach(var sBoxNum in activatedSboxesNums)
			{
				var byteNum = sBoxNum / 2;
				var b = (byte)((got[byteNum] >> (sBoxNum % 2 == 0 ? 4 : 0)) & 0x0F);
				yield return new Solution
				{
					HalfByte = b,
					SBoxNum = sBoxNum,
					score = 1 / Math.Pow(2, groupNum)
				};
			}
		}

		private static bool IsValidKey(byte[] expected, byte[] got, ICollection<int> lastRoundSBoxesNums)
		{
			foreach(var sBoxNum in lastRoundSBoxesNums)
			{
				var byteNum = sBoxNum / 2;
				if(((got[byteNum] ^ expected[byteNum]) & (sBoxNum % 2 == 0 ? 0xF0 : 0x0F)) != 0)
					return false;
			}
			return true;
		}
	}

	class Solution
	{
		public int SBoxNum;
		public byte HalfByte;
		public double score;
	}
}
